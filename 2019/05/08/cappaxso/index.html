<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="谈谈自己对分布式一致性算法的理解"><meta name="keywords" content="paxso raft gossip qurorum"><meta name="author" content="zhuyuping"><meta name="copyright" content="zhuyuping"><title>谈谈自己对分布式一致性算法的理解 | 朱遇平的github博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.0"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">zhuyuping</div><div class="author-info__description text-center">掌握java相关知识，擅长大数据，以及机器学习算法应用方面 java scala python</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">朱遇平的github博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">谈谈自己对分布式一致性算法的理解</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-08</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>说起分布式一致性算法，就要讲到CAP原则，我们在多机器之间、多副本之间如果不需要强一致性，直接读写 主从（半）异步同步就行，但是总是有一些场景，需要保证每次获取到结果都是一致性的，比如资源注册管理一些metadata schema信息，一致性状态，各个副本或者节点之间操作严重依赖彼此数据一致，这时候需要保证一致性或者最终一致性。总体来说现有一些zookeeper consul etcd atom一些开源框架实现了这些一致性算法。<br>这类算法有个基本思想就是（NWR除外）对于每台机器相同的初始状态，或者某个时间相同的初始状态，如果经过的状态系列变更相同最后的结果一定是相同的，同样对于相同的变更系列分为2种一种是基于过程的变更系列 这叫做复制状态机，比如paxso raft 记录变更的前后日志信息，还有一种是基于结果的变更系列 这叫做primary-backUp。比如zookeeper ZAB基于数据结果的变更系列。在了解分布式一致性算法前，请先知道一个问题什么是2PC，网上文字很多这里就不说了，其实网上很多paxso 算法太多抽象难懂，我也看过很多，但是太过晦涩难懂，下面就用我理解的方式来说吧，我以前也没怎么搞懂，后来看了一下mutipaxso一些框架实现的源码，渐渐的懂了。首先我们知道 2个角色，一个提案者 一个议会者，<br>他是怎么做的呢？ 让我们想象一个场景，读书时候，学校搞庆祝活动，<br>我们一大群人去操场抢位置，每个人都想抢到一个靠前的座位，比如 1–20 20-30 30-40 ，但是实际上很多空位，有可能一部分同学去厕所了，去组织表演了，这时候来了一个同学（请求）我先看中1号座位，所以他会做这些事情， 我想周边的在的人询问 这个1号座位 有人占了吗？但是每个人知道的可能不一样，因为也许别人没有关注这些，根本不知道，但是对于每个人来说他总不知道，或知道<br>我知道哪些之前位置座位有人占了，我知道几号座位刚刚谁占了，但是我们不可能记住每一个座位，但是我们知道 1 2 3 4 5 6 7 这数字顺序是不变的，如果我们能按照这个顺序来占的话，一步步确认保证，是不是从1 、、、到N被占信息如果都确定了，只需要知道 某个N就行了，<br>好，下面我们做2次询问来看看能不能占当前这个座位N 。<br>   第一阶段：<br>   A.我们发起第一次询问，问旁边的人，座位N 有人占了吗？ 所有人收到消息的根据自己记得信息答复，比如他记得N之前的之前的座位都被占了但是反正当前N没被占，那么他就答复 可以占ack，否则不答复，同时这个答复的人心里打了小九九，知道了有人对N座位有人想要占了，<br>   这就对应paxos的</p>
<p>   <strong>Prepare阶段：<br>Proposer选择一个提案编号n并将prepare请求发送给 Acceptor。<br>Acceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息，则Acceptor将自己上次接受的提案回复给Proposer，并承诺不再回复小于n的提案。</strong><br>其中座位号是编号N，要记录的信息是<br>（minProposerId,acceptId,acceptValue）是其他同学心里记得占了的信息 只需要记得哪个之前的座位占了就行，这样同学来问，我就知道该回还是不回了。<br> 第二阶段：<br> B.当超过半数的同学都回我，告诉我这个位置现在还没有占，应该可以占。这时候我肯定去确认并试图占下来，我就告诉其他同学，我要宣告我要占这个座位了，如果这个我们去占的时候，还没人占，好，那我们占下来，其他同学也知道了，心里记下了，座位N已经做了谁啊，N之前的都已经确定了，但是询问发现假如这期间另外一同学已经把位置占了，这时候我们知道泡汤了，我们只能默默的让给他，自己知道N已经被谁做了，但是我们可以去抢N+1的座位吧，重新进行询问。</p>
<p> 这就是paxso 第二个过程</p>
<p> <strong>Accept阶段：<br>当一个Proposer收到了多数Acceptor对prepare的回复后，就进入批准阶段。它要向回复prepare请求的Acceptor发送accept请求，包括编号n和根据prepare阶段决定的value（如果根据prepare没有已经接受的value，那么它可以自由决定value）。<br>在不违背自己向其他Proposer的承诺的前提下，Acceptor收到accept请求后即接受这个请求。</strong></p>
<p>总体来看就是通过座位 1 &lt; 2 &lt; 3 &lt;4 &lt;n 这种有顺序的简单数字顺序，我们来放每次接收到的变更命令请求 一个坑一个坑的往里面放，这有什么好处呢，因为这样有顺序，一旦多数投票节点已经确定知道了某个K 坑已经被占了，代表这这些人知道原来之间1 …到k-1是被占了的，这样不管怎样，也就是说2次询问，不管中间那些节点丢失了链接失联了，他只要发起1….k-1坑的询问，<br>通过多数投票的这些节点知道2次交互，<br>每次都肯定返回同样的结果,而且也能得到原来我不知道的那些坑已经有人占了啊的信息，这相当于查询，这样那些不知道的失联节点可以通过这样询问，同步更新自己知道的信息，最终保证一致性。</p>
<p>这样应该清晰了吧，这是我的理解，其实这basic paxso 有2个问题，1.1个是活锁问题，第二个是2次询问交互时间问题，所以在mutipaxso 问题上就改进了，活锁是因为多个同学可能同时都要抢座位并发问题，导致有些同学一直没抢到一直问下一个下一个座位，问的都快哭了，所以选出一个班主任leader，通过班主任来统一进行询问安排座位，2.2次交互时间问题，因为统一了班主任来问了，所以班主任在问的时候不要每次都问，只需要说我要询问安排座位了，然后就问这个作为能不能做，那个能不能做就行。</p>
<p>今天回家有点晚了 ，先说到这里吧。<br>后面有时间补充raft zab 一些改进的思想，其实跟mutipaxso很像。就像paxso 里面的同学记得n之前的座位被占了信息，在raft里面就是日志以及commitId,下次有时间在补充。</p>
<p>今天接着讲一下 我对Raft的理解，2013 年raft算法开始出现，其实Raft 有点类似上面的paxos的mutiPaxso改进，mutiPaxso没有要求保证同一个时间同一个任期只有一个leader,但是Raft算法保证了，那应该怎么保证呢？ 我们回想一下paxso上面讲的那个N 以及 N-1 之前的座位确认，我们就很快想到，我们把任期也做成一个N N-1之前的座位号确认就行，在Raft 他叫做term ，同时以前的同学占座的那个N 是我们最终要每个同学都一致认同的已知信息，这个N 在Raft 里面就是他的日志的commitIndex ,所以思想很相似吧，有时候你把raft当做paxso的改进也未尝不可。对于Raft来说保证每一次只有有一个leader 所以他就有一个选举阶段。选举跟上面paxso一样，肯定要那个term最大，知道的信息最多（commitIndex最新）的人才能当选班主任啊，<br>啊，同样成为leader后 班主任就要同步我知道的信息给现场同学或者一些刚到的同学，所以有一个消息同步阶段，这里想象班主任跟同学同步信息，怎么做，肯定是说我这边到N的座位都是已经确定的，同学心里想我只记得到K的座位都是确定了的，那么我把班主任知道的K-N之间的信息记下来，这样我也知道到N的所有座位情况了，如果班主任跟我知道座位做的人不一样，那肯定是我错了，我就删除更新记下班主任知道的情况，其他的各类情况反正根据情况考虑就行了，这就是第二个阶段 ，假如下午时候班主任突然生病住院了，是不是会有代课老师来负责安排这些工作，这时候 就是第三阶段重新选举并恢复阶段，代课老师成了代理班主任，这时候肯定给所有同学做一个宣告，广播，告诉同学们，最近这段时间我代理班主任职务来负责，这时候同学都记得了，term+1了，最新的记忆里面都知道了最新的班主任是谁，但是实际上raft 跟 现实有点不一样，假如班主任又突然好了回来了，这时候本应该是他回来当班主任，但是在raft里面就不一定了，因为当前的是term+1比班主任term要大，班主任成不了leader了，只能等代理班主任当完代理完走，下次再去选举了，所以如果按照这个场景来分析，其实可以实现leader节点群，follower节点群，leader节点就是班主任有其他备选的一些，也许做做投票议会，优先级权利比follower节点更高，kafka里面这有点类似ISR，只有ISR（班主任病了时候有资格代理班主任的）才能当选班主任。就讲这么多吧。ZAB 跟Raft很类似。大家可以相同的理解就行。但是里面同步消息有点不太一样。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zhuyuping</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/05/08/cappaxso/">http://yoursite.com/2019/05/08/cappaxso/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/paxso-raft-gossip-qurorum/">paxso raft gossip qurorum</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/05/07/image-model/"><span>2019-05-08 图像方面的一些尝试</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By zhuyuping</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.0"></script><script src="/js/fancybox.js?version=1.6.0"></script><script src="/js/sidebar.js?version=1.6.0"></script><script src="/js/copy.js?version=1.6.0"></script><script src="/js/fireworks.js?version=1.6.0"></script><script src="/js/transition.js?version=1.6.0"></script><script src="/js/scroll.js?version=1.6.0"></script><script src="/js/head.js?version=1.6.0"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>